# -*- coding: utf-8 -*-
"""AlgLab2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1W5qQT2UmTfiPnUqHIBDNDrUA3ogtij3t
"""

!pip install bitarray

import random
import string

FILENAME = 'data'

def generate_data(num_of_rows, filename):
  with open(f"{filename}.txt", "w") as f:
    for i in range(num_of_rows):
      word_length = random.randint(1, 15)
      word_operation = random.choice('+?')
      word_text = ''.join(random.choices(string.ascii_lowercase, k=word_length))
      f.write(f"{word_operation} {word_text}\n")
    f.write('#')

generate_data(10**6, FILENAME)

import numpy as np
import random
import math
import sympy
from bitarray import bitarray

class PolinomialHashes:
  def __init__(self, l, m):
    self.l = l
    self.m = m
    self.coefs = []
    self.p = sympy.randprime(self.m, self.m*1000)
    self.generateCoefs()

  def generateCoefs(self):
    for i in range(self.l):
        current_coefs = random.sample(range(0, self.p-1), 15)
        current_coefs.append(random.randint(1, self.p-1))
        self.coefs.append(current_coefs)

  def getPowers(self, index):
    powers = []
    for i in range(16):
      powers.append(pow(self.coefs[index][i], index, self.p))
    return powers

  def getHash(self, index, word):
    hash = 0
    powers = self.getPowers(index)
    for i, char in enumerate(word):
      hash = (hash + powers[i] * ord(char)) % self.m
    hash = (hash + powers[-1]) % self.m
    return hash


class Bloom:
  def __init__(self, n, p):
    self.n = n
    self.p = p
    self.getOptimalValues()
    self.initializeHashFunctions()
    self.bit_array = bitarray(self.m)
    self.bit_array.setall(0)

  def getOptimalValues(self):
    self.l = math.ceil(-np.log(self.p)/np.log(2))
    self.m = math.ceil(-self.n*np.log(self.p)/np.power(np.log(2), 2))
    print(f"Оптимальна кількість різних геш-функцій: {self.l}\n" \
            f"Оптимальний розмір масиву: {self.m}")

  def initializeHashFunctions(self):
    self.hashes = PolinomialHashes(self.l, self.m)

  def addElement(self, word):
    positions = []
    for i in range(self.l):
      positions.append(self.hashes.getHash(i, word))
    for p in positions:
      self.bit_array[p] = 1

  def checkElement(self, word):
    positions = []
    for i in range(self.l):
      positions.append(self.hashes.getHash(i, word))
    for p in positions:
      if self.bit_array[p] == 0: return f"{word} - N"
    return f"{word} - Y"

def fill_structure(filter):
  with open(f"{FILENAME}.txt", "r") as f:
    for row in f:

      if row == '#':
        print('End of file')
        return

      splitted = row.split()
      operation, word = splitted[0], splitted[1]

      if not (len(word) <= 15 and word.islower() and word.isalpha()):
        print(f'Word {word} is invalid input data')
        continue

      if operation == '+':
        filter.addElement(word)
      elif operation == '?':
        print(filter.checkElement(word))
      else:
        print(f"For word {word} invalid operation requested")

bloomFilter = Bloom(10**6, 0.01)
fill_structure(bloomFilter)

